# from curses.ascii import isupper
#
# name = "채현호"
# age = 39.15
# "제 이름은  ___ 입니다."
# print("제 이름은" + name + "입니다.")
# print("제 이름은", name, "입니다")
# print("제 나이는", age ,"입니다")
#
# print("제 나이는 {} 이고 이름은 {}입니다.".format(age, name))
#
# print("제 나이는 {a} 이고 이름은 {b}입니다.".format(a=39, b="채현호")) #name="채현호"와 같은 변수를 미리 만들지 않고 바로 format에서 적용 할수 있음
# print(f"제 나이는 {age} 이고 이름은 {name}입니다.") #미리 변수들이 만들어져 있는 경우 불러옴
# print("제 나이은 %s 입니다." % age) # 문자열로 들어간다.
# print("제 나이는 %d 입니다." % age) # 모든 숫자가 정수로 들어간다.
# print(f"제 나이는 %d 이고 이름은 %s 입니다." %(age, name)) #f포맷 %d 정수 %s 문자열
#
# print("제 지분은 %d%% 입니다." % 2) #%% 는 % 퍼센트의 문자열
#
# print("%10.2f" %3.1412345) #%"자릿수" '.' "몇번째 소수점f"
# from xml.sax.saxutils import prepare_input_source

#입력 = input() #입력 함수 자료를 직접 넣음. input에 입력되는 것은 무조건 문자열로 인식함.

#이름 = input("이름 : ")
#나이 = input("나이 : ") #소수점으로 입력된 문자열을 출력시 정수로 변환하고 싶을때는 int(float(input("나이 : ")) int=정수 float=실수
#이메일 = input("이메일 : ")
#취미 = input("취미 : ")

#print(f"제 이름은 {이름}이고 나이는 {나이}입니다. 이메일은 {이메일}이며, 취미는 {취미} 입니다.")

#문자열의 인덱싱
#인덱싱은 0으로 시작한다. 글자수를 가르킨다 지정위치. 0 1 2 3 4 5 6 7 8 9 10 11 12
#인덱싱은 역순으로 가르킬 수 있다. -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1

# a = "life is too short, you need python"
# print(a[-4]) [] 가 인덱스 실행 예약어

# 문자열 슬라이싱 [   :    :   ]
#ㅊ
#print(a[4:8]) #[   :   ] 첫자리는 스타트 위치, 뒷자리는 마지막 자리 앞을 나타냄  >> is  4번째 i 8번째 자리 앞 s
#print(a[2:10:2]) #[  :   :  ] 첫자리는 스타트 위치. 두번째 자리는 마지막 자리 앞을 나타냄, 마지막 자리는 첫자리에서 증가하는 위치 전체다 >>> fio

# date = "20250218맑음"
# date2 = "20260505흐림"
# 출력문제 - 연도, 월, 일, 날씨
# 출력문제 - 연도는 2025, 월은 02 일은 18 날씨는 맑음
# print(date[0:4])
# print(date[4:6])
# print(date[6:8])
# print(date[8:10])
#
# print(f"연도는 {date[0:4]}, 월은 {date[4:6]}, 일은 {date[6:8]}, 날씨는 {date[8:10]}")
# print(f"연도는 {date2[0:4]}, 월은 {date2[4:6]}, 일은 {date2[6:8]}, 날씨는 {date2[8:10]}")  # 첫자리 [0:4] 를 [:4] 해도됨. 끝자리는 [8:] 해도됨
#>>> 연도는 2025, 월은 02, 일은 18, 날씨는 맑음
#>>> 연도는 2026, 월은 05, 일은 05, 날씨는 흐림

# a = "life is too short, you need python"
# print(len(a)) # 문자열 길이  >>> 34
# print(a.count("t")) #특정 문자 갯수 검색  >>> 3
# print(a.count(x:"t", __start:5, __end:10)) #특정 문자가 몇개 있는지
# print(a.index("x")) #앞에서 부터 찾는데 해당 문자의 인덱스 번호를 찾는데 없으면 에러를 띄운다.
# print(a.index("t")) # "  "안에 있는 전체 문자열 앞에서 부터 찾는 데 해당 문자의 인덱스 번호이다. 공백(띄어쓰기)도 포함.
# print(a.find("x")) #find는 없으면 -1로 출력한다.
# print(a.upper()) #upper 대문자로 변환 low 소문자 변환
# print(a[0].isupper()) #a[0]은 첫번째 단어가 l이 대문자인지 질문하는것
# print(a.replace(__old:"short", __new:"long")) 특정 단어를 대체 __olddhk __new는 직접 입력하는 것이 아님.
# print(a.strip()) #strip = 공백을 제거 하는 예약어, lstrip은 외쪽 공백 rstrip은 오른쪽 공백 제거" a=""    가나다라 마바사       "" 일경우 >> lstrip = "가나다라 마바사       "!!에러
# print(a.split()) # 띄어쓰기로 나누어서 리스트를 보여줌

# ----------------------------------------------------
# 3회차
# 1교시----------------
#과제 : 이메일 = input("이메일 : ") #asdf@adsf.com 일 경우 아이디만 추출하고 싶을때
# 이메일 = input("이메일 : ")
# print([:이메일.find("@")])
# 정답 : print(이메일[:이메일.find("@")])
# 이메일[:] 슬라싱
# 골벵이의 인덱스 번호를 찾아야 한다.
# 풀이 1. 먼저  인덱스 또는 파인드를 이용해서 골뱅이 위치를 찾아야 한다.
#         이메일.find("@") or 이메일.index("@")
#         print(이메일[:이메일.find["@"])
# 풀이 2. 이메일.split("@")[0]
# !! 정답 : print(이메일.split("@")[0])

# 컬렉션 : 여러개의 데이터를 저장하고 관리하는 자료 구조 (리스트,튜플 딕셔너리 세트)
# 리스트(list) : 순서가 있고 중복가능, 요소 추가/삭제 가능 => 변경 가능
#               예) 과일 = ["사과", "바나나", "체리"] 변수명 안에 리스트 작성

# 리스트 = ["사과", "딸기", "오렌지"] # 문자열 리스트     리스트는 [] 를 사용
# 숫자 = [1, 7, 3, 10, 9] # 숫자 리스트
# bools = [True, False, True] #불리언 리스트 (참/거짓)
# mixed_list = ["안녕하세요", 12, True]

# print(리스트[2]) #인덱스를 이용해서 내가 원하는 특정 요소만 추출 >>> 2는 오렌지 (0 사과 1 딸기 2 오렌지)
# print(리스트[2][1]) #인덱스 안에서 또다른 인덱스 추출 >>> 렌 ( 0 오 1 렌 2 지)
# print(리스트[-2]) #인텍스를 역순으로 추출 >>> 딸기 (-3 사과, -2 딸기, -1 오렌지)
# 리스트[1] = "수박" #인덱스를 수정 한다. >>>  변수명 상장에서 (0 사과 1 수박 2 오렌지) 딸기가 없어짐
         # print(리스트) >>> 사과, 수박, 오렌지 출력됨
# 숫자.append("hi") #요소를 맨 끝에 추가 >>> print(숫자)
# 숫자.insert(1,2) #요소와 요소 사이에 추가 >>>  print(숫자) >>>  [1, 2, 3, 5, 7, 9, 'hi'] (인덱스 1자리에 3 앞에 2를 추가)

# print(숫자.pop()) #pop은 리스트의 제일 마지막 만 출력 된다. pop은 출력되면서 삭제가 된다. hi만 출력되고 리스트를 다시 부르면 hi 삭제되어 있고, 남은 리스트만 출력
# print(숫자)

# 숫자.remove("hi") # 선택적 요소 삭제 [1, 2, 3, 5, 7, 9, 'hi'] 안에서 hi 만 삭제
# print(숫자) #>>> [1, 2, 3, 5, 7, 9]

# del 숫자[6] # 특정 위치 요소를 인덱스 넘버로 삭제
# print(숫자)

# print(len(mixed_list)) #리스트의 길이를 알려줌 >>> 3 (["안녕하세요", 12, True]) 3가지 목록이라서 3이 출력

# 숫자.sort() # 작은 순으로 정렬
# print(숫자)  >>>  [1, 3, 7, 9, 10] 원본 : [1, 7, 3, 10, 9]

# bools.sort()  # 작은 순으로 정렬
# print(bools)  # >> [False, True, True]   원본 : [True, False, True]

# 숫자.sort(reverse=True) # 높은 순으로 정렬 (단, 리버스는 기본값으로 거짓으로 인지해서 트루를 넣어야함)
# print(숫자)
#
# bools.sort(reverse=True)
# print(bools)

# 숫자.reverse() # 그냥 순서를 거꾸로 만든다.
# print(숫자) >>> [9, 10, 3, 7, 1]  원본 : [1, 7, 3, 10, 9]

# 리스트 = "-".join(리스트) # 지정한 요소로 리스트안의 데이터를 다 이어준다.
# print(리스트) >>> 사과-딸기-오렌지  원본 : ["사과", "딸기", "오렌지"]

# 퀴즈
# cart = [ ] # 빈상자의 변수를 만들고 직접 입력을 받아서 출력하도록 하기
# cart = []
# cart.append(input("상품1 : "))    #append : 데이터를 추가
# cart.append(input("상품2 : "))
# cart.append(input("상품3 : "))
# print(cart)


# 2교시--------------------------------------
# 튜플 : 순서가 있지만, 요소 변경 불가능 => 데이터를 만들고 해당 데이터는 변경 불가능하게 함
# 예 )contract=("계약기간 : 100년", " 시급:100원", "보증금:500만원")
# 예 ) =("김철수", 1995, "서울"

# 컬러 = ("레드", "그린", "블랙") # 변경 불가능    튜플은 ()을 사용
# 넘버 = (1, 5, 3, 9)
# bools = (True, False, True)
# 믹스 = ("레드", 1, True)

# a = ("first", ) # 튜플에서 요소가 하나 일때는 뒤에 쉼표를 붙어야한다.

# print(컬러[1]) >>> 그린
# print(컬러[1] = "옐로우" # 튜블은 변경 불가능 >> 에러
# print(넘버[0:2]) # 슬라이싱 가능 >> 1, 5
# print(넘버.count(1)) #      >>> 1
# print(넘버.index(3)) #     >>> 2

# a, b, c = 컬러 # 언페킹 : 컬러 박스 안에 있는 리스트를 첫번째를 a로 두번째를 b로 세번째로 c로 지정한다.  원본 : "레드", "그린", "블랙"
# print(c) # c로 지정된 데이터를 불러온다. >>> 블랙
# a, b, c, d = 컬러 # 언페킹에서 기존 데이터보다 지정 언페킹이 많을 경우 에러가 된다.

