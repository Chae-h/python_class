# from curses.ascii import isupper
#
# name = "채현호"
# age = 39.15
# "제 이름은  ___ 입니다."
# print("제 이름은" + name + "입니다.")
# print("제 이름은", name, "입니다")
# print("제 나이는", age ,"입니다")
#
# print("제 나이는 {} 이고 이름은 {}입니다.".format(age, name))
#
# print("제 나이는 {a} 이고 이름은 {b}입니다.".format(a=39, b="채현호")) #name="채현호"와 같은 변수를 미리 만들지 않고 바로 format에서 적용 할수 있음
# print(f"제 나이는 {age} 이고 이름은 {name}입니다.") #미리 변수들이 만들어져 있는 경우 불러옴
# print("제 나이은 %s 입니다." % age) # 문자열로 들어간다.
# print("제 나이는 %d 입니다." % age) # 모든 숫자가 정수로 들어간다.
# print(f"제 나이는 %d 이고 이름은 %s 입니다." %(age, name)) #f포맷 %d 정수 %s 문자열
#
# print("제 지분은 %d%% 입니다." % 2) #%% 는 % 퍼센트의 문자열
#
# print("%10.2f" %3.1412345) #%"자릿수" '.' "몇번째 소수점f"
# from xml.sax.saxutils import prepare_input_source

#입력 = input() #입력 함수 자료를 직접 넣음. input에 입력되는 것은 무조건 문자열로 인식함.

#이름 = input("이름 : ")
#나이 = input("나이 : ") #소수점으로 입력된 문자열을 출력시 정수로 변환하고 싶을때는 int(float(input("나이 : ")) int=정수 float=실수
#이메일 = input("이메일 : ")
#취미 = input("취미 : ")

#print(f"제 이름은 {이름}이고 나이는 {나이}입니다. 이메일은 {이메일}이며, 취미는 {취미} 입니다.")

#문자열의 인덱싱
#인덱싱은 0으로 시작한다. 글자수를 가르킨다 지정위치. 0 1 2 3 4 5 6 7 8 9 10 11 12
#인덱싱은 역순으로 가르킬 수 있다. -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1

# a = "life is too short, you need python"
# print(a[-4]) [] 가 인덱스 실행 예약어

# 문자열 슬라이싱 [   :    :   ]
#ㅊ
#print(a[4:8]) #[   :   ] 첫자리는 스타트 위치, 뒷자리는 마지막 자리 앞을 나타냄  >> is  4번째 i 8번째 자리 앞 s
#print(a[2:10:2]) #[  :   :  ] 첫자리는 스타트 위치. 두번째 자리는 마지막 자리 앞을 나타냄, 마지막 자리는 첫자리에서 증가하는 위치 전체다 >>> fio

# date = "20250218맑음"
# date2 = "20260505흐림"
# 출력문제 - 연도, 월, 일, 날씨
# 출력문제 - 연도는 2025, 월은 02 일은 18 날씨는 맑음
# print(date[0:4])
# print(date[4:6])
# print(date[6:8])
# print(date[8:10])
#
# print(f"연도는 {date[0:4]}, 월은 {date[4:6]}, 일은 {date[6:8]}, 날씨는 {date[8:10]}")
# print(f"연도는 {date2[0:4]}, 월은 {date2[4:6]}, 일은 {date2[6:8]}, 날씨는 {date2[8:10]}")  # 첫자리 [0:4] 를 [:4] 해도됨. 끝자리는 [8:] 해도됨
#>>> 연도는 2025, 월은 02, 일은 18, 날씨는 맑음
#>>> 연도는 2026, 월은 05, 일은 05, 날씨는 흐림

# a = "life is too short, you need python"
# print(len(a)) # 문자열 길이  >>> 34
# print(a.count("t")) #특정 문자 갯수 검색  >>> 3
# print(a.count(x:"t", __start:5, __end:10)) #특정 문자가 몇개 있는지
# print(a.index("x")) #앞에서 부터 찾는데 해당 문자의 인덱스 번호를 찾는데 없으면 에러를 띄운다.
# print(a.index("t")) # "  "안에 있는 전체 문자열 앞에서 부터 찾는 데 해당 문자의 인덱스 번호이다. 공백(띄어쓰기)도 포함.
# print(a.find("x")) #find는 없으면 -1로 출력한다.
# print(a.upper()) #upper 대문자로 변환 low 소문자 변환
# print(a[0].isupper()) #a[0]은 첫번째 단어가 l이 대문자인지 질문하는것
# print(a.replace(__old:"short", __new:"long")) 특정 단어를 대체 __olddhk __new는 직접 입력하는 것이 아님.
# print(a.strip()) #strip = 공백을 제거 하는 예약어, lstrip은 외쪽 공백 rstrip은 오른쪽 공백 제거" a=""    가나다라 마바사       "" 일경우 >> lstrip = "가나다라 마바사       "!!에러
# print(a.split()) # 띄어쓰기로 나누어서 리스트를 보여줌

# ----------------------------------------------------
# 3회차
# 1교시----------------
#과제 : 이메일 = input("이메일 : ") #asdf@adsf.com 일 경우 아이디만 추출하고 싶을때
# 이메일 = input("이메일 : ")
# print([:이메일.find("@")])
# 정답 : print(이메일[:이메일.find("@")])
# 이메일[:] 슬라싱
# 골벵이의 인덱스 번호를 찾아야 한다.
# 풀이 1. 먼저  인덱스 또는 파인드를 이용해서 골뱅이 위치를 찾아야 한다.
#         이메일.find("@") or 이메일.index("@")
#         print(이메일[:이메일.find["@"])
# 풀이 2. 이메일.split("@")[0]
# !! 정답 : print(이메일.split("@")[0])

# 컬렉션 : 여러개의 데이터를 저장하고 관리하는 자료 구조 (리스트,튜플 딕셔너리 세트)
# 리스트(list) : 순서가 있고 중복가능, 요소 추가/삭제 가능 => 변경 가능
#               예) 과일 = ["사과", "바나나", "체리"] 변수명 안에 리스트 작성

# 리스트 = ["사과", "딸기", "오렌지"] # 문자열 리스트     리스트는 [] 를 사용
# 숫자 = [1, 7, 3, 10, 9] # 숫자 리스트
# bools = [True, False, True] #불리언 리스트 (참/거짓)
# mixed_list = ["안녕하세요", 12, True]

# print(리스트[2]) #인덱스를 이용해서 내가 원하는 특정 요소만 추출 >>> 2는 오렌지 (0 사과 1 딸기 2 오렌지)
# print(리스트[2][1]) #인덱스 안에서 또다른 인덱스 추출 >>> 렌 ( 0 오 1 렌 2 지)
# print(리스트[-2]) #인텍스를 역순으로 추출 >>> 딸기 (-3 사과, -2 딸기, -1 오렌지)
# 리스트[1] = "수박" #인덱스를 수정 한다. >>>  변수명 상장에서 (0 사과 1 수박 2 오렌지) 딸기가 없어짐
         # print(리스트) >>> 사과, 수박, 오렌지 출력됨
# 숫자.append("hi") #요소를 맨 끝에 추가 >>> print(숫자)
# 숫자.insert(1,2) #요소와 요소 사이에 추가 >>>  print(숫자) >>>  [1, 2, 3, 5, 7, 9, 'hi'] (인덱스 1자리에 3 앞에 2를 추가)

# print(숫자.pop()) #pop은 리스트의 제일 마지막 만 출력 된다. pop은 출력되면서 삭제가 된다. hi만 출력되고 리스트를 다시 부르면 hi 삭제되어 있고, 남은 리스트만 출력
# print(숫자)

# 숫자.remove("hi") # 선택적 요소 삭제 [1, 2, 3, 5, 7, 9, 'hi'] 안에서 hi 만 삭제
# print(숫자) #>>> [1, 2, 3, 5, 7, 9]

# del 숫자[6] # 특정 위치 요소를 인덱스 넘버로 삭제
# print(숫자)

# print(len(mixed_list)) #리스트의 길이를 알려줌 >>> 3 (["안녕하세요", 12, True]) 3가지 목록이라서 3이 출력

# 숫자.sort() # 작은 순으로 정렬
# print(숫자)  >>>  [1, 3, 7, 9, 10] 원본 : [1, 7, 3, 10, 9]

# bools.sort()  # 작은 순으로 정렬
# print(bools)  # >> [False, True, True]   원본 : [True, False, True]

# 숫자.sort(reverse=True) # 높은 순으로 정렬 (단, 리버스는 기본값으로 거짓으로 인지해서 트루를 넣어야함)
# print(숫자)
#
# bools.sort(reverse=True)
# print(bools)

# 숫자.reverse() # 그냥 순서를 거꾸로 만든다.
# print(숫자) >>> [9, 10, 3, 7, 1]  원본 : [1, 7, 3, 10, 9]

# 리스트 = "-".join(리스트) # 지정한 요소로 리스트안의 데이터를 다 이어준다.
# print(리스트) >>> 사과-딸기-오렌지  원본 : ["사과", "딸기", "오렌지"]

# 퀴즈
# cart = [ ] # 빈상자의 변수를 만들고 직접 입력을 받아서 출력하도록 하기
# cart = []
# cart.append(input("상품1 : "))    #append : 데이터를 추가
# cart.append(input("상품2 : "))
# cart.append(input("상품3 : "))
# print(cart)


# 2교시--------------------------------------
# 튜플 : 순서가 있지만, 요소 변경 불가능 => 데이터를 만들고 해당 데이터는 변경 불가능하게 함
# 예 )contract=("계약기간 : 100년", " 시급:100원", "보증금:500만원")
# 예 ) =("김철수", 1995, "서울"

# 컬러 = ("레드", "그린", "블랙") # 변경 불가능    튜플은 ()을 사용
# 넘버 = (1, 5, 3, 9)
# bools = (True, False, True)
# 믹스 = ("레드", 1, True)

# a = ("first", ) # 튜플에서 요소가 하나 일때는 뒤에 쉼표를 붙어야한다.

# print(컬러[1]) >>> 그린
# print(컬러[1] = "옐로우" # 튜블은 변경 불가능 >> 에러
# print(넘버[0:2]) # 슬라이싱 가능 >> 1, 5
# print(넘버.count(1)) #      >>> 1
# print(넘버.index(3)) #     >>> 2

# a, b, c = 컬러 # 언페킹 : 컬러 박스 안에 있는 리스트를 첫번째를 a로 두번째를 b로 세번째로 c로 지정한다.  원본 : "레드", "그린", "블랙"
# print(c) # c로 지정된 데이터를 불러온다. >>> 블랙
# a, b, c, d = 컬러 # 언페킹에서 기존 데이터보다 지정 언페킹이 많을 경우 에러가 된다.




# 4회차  딕셔너리 { : }
# 1교시------------------------------------
# 프로필 = {"name":"홍길동", "age" : "30", "hobby" : ["여행하기", "음악듣기"]}
# print(프로필)
# 프로필 = {"name":"홍길동", "age" : "30", "hobby" : ["여행하기", "음악듣기"]}
# print(프로필)
# print(프로필["name"]) #인덱스 []를 이용해서 딕셔너리의 요소 가져오기
# print(프로필["hobby"][1]) #인덱스 []를 이용해서 딕셔너리의 요소 가져오기 + 리스트 요소 빼오기 >>>> 음악듣기
#
# 프로필["age"] = 28 #딕셔너리의 내용을 수정할때. 인덱스 ["요소"] 지정 =  수정내용
# print(프로필) >>> {'name': '홍길동', 'age': 28, 'hobby': ['여행하기', '음악듣기'], 2: '이'}

# 프로필["jod"] = "강사" # 딕셔너리에서는 어펜트를 사용하지 않고 새로운 부분을 그대로 입력하면된다. (어펜드는 [] 리스트에 추가할때문 사용)
# print(프로필) #딕셔너리에서는 기존에 있는 인덱스 요소에 내용을 넣으면 수정되고 기존에 없는 데이터는 추가된다. >>>{'name': '홍길동', 'age': 28, 'hobby': ['여행하기', '음악듣기'], 2: '이', 'jod': '강사'}

# del 프로필["jod"] # 삭제 방법. 딕셔너리에서 del 변수명["요소"] 삭제
# print(프로필) >> {'name': '홍길동', 'age': 28, 'hobby': ['여행하기', '음악듣기']}

# key_list = 프로필.keys() #기존 딕셔너리를 가지고  (새로운 변수명 = 기존 프로필 상자에서 . key를 넣는다)
# # print(key_list) >>> dict_keys(['name', 'age', 'hobby'])

# key_list = list(프로필.keys()) # 새로운 키리스트 변수 폴더에서 키만 리스트 [] 로 추출
# print(key_list) #>>> ['name', 'age', 'hobby']

# values()#딕셔너리의 키의 값만 추출하기
# valuse_list = list(프로필.values()) # 새로운 변수 폴더에 기존의 프로필 변수 폴더에 있는 키의 값을 리스트로 추출
# print(valuse_list) >>> ['홍길동', 28, ['여행하기', '음악듣기']]

# 프로필.items() # 키 - 값 형태로 다 뽑아내기
# 프로필.items()
# print(프로필.items())
# item_list = list(프로필.items())
# print(item_list) # >>> [('name', '홍길동'), ('age', 28), ('hobby', ['여행하기', '음악듣기'])]
# item_list.append(("jod", "강사")) # append는 리스트 [] 안에 요소를 추가
# print(item_list)


# 2교시----------------------------------------------------------
# python_grade = {"동윤":"B", "길동":"C", "준식":"A", "상혁":"D"}
# # print(sorted(python_grade.items())) >>> [('길동', 'C'), ('동윤', 'B'), ('상혁', 'D'), ('준식', 'A')]
# # 키 기준 오름차순(sorted)
#
# # print(sorted(python_grade.items(), reverse=True)) #키 기준 내림차순
# # >>>> [('준식', 'A'), ('상혁', 'D'), ('동윤', 'B'), ('길동', 'C')]
#
# print(sorted(python_grade.items(), key=lambda x: x[1])) # key를 람다로 인식 (동윤:B)  하나로 인식하고 그중 x : x의[1] 값으로 기준하여 오름으로 정렬(?)
# # >>> [('준식', 'A'), ('동윤', 'B'), ('길동', 'C'), ('상혁', 'D')]
#
# print(sorted(python_grade.items(), key=lambda x: x[1], reverse=True))
# # >>> [('상혁', 'D'), ('길동', 'C'), ('동윤', 'B'), ('준식', 'A')] 역순으로 출력

# 퀴즈. student = {} 라는 딕셔너리 변수 안에 '이름' '점수' 입력 받고 출력하기
# student = {}  출력값이 {"name" : "홍길동", "score": 80} 이렇게 나오게
#
# 내가 풀어본것
# student["이름"] = input()  # student 변수 폴더에 ["이름"]라는 리스트를 넣는다 = 키 값은 input()으로 받겠다.
# student["점수"] = input()
# print(student) # >>>  {'이름': '홍길동', '점수': '80'}  << '90' 점수가 문자열로 인식중

# 퀴즈 풀이1   #input으로 받은 모든 데이터는 문자열로 인식한다.
# student = {"name":input("이름:"), "score":input("점수:")}  #한번에 입력받는 함수
# print(student) # >>> {'이름': '홍길동', '점수': '90'}  점수가 '  ' 감싸지면서 문자열로 인식중

# 퀴즈 풀이2
# student["이름"] = input("이름 : ")
# student["점수"] = int(input("점수 : "))  # 점수를  int(정수)로 받겠다는 함수를 추가 해야한다.
# print(student) >>> {'이름': '홍길', '점수': 34}



# 세트(set) : 중복을 허용하지 않고, 순서가 없는 데이터 모음, 수학에서 말하는 집합 개념과 유사함, 순서가 없기 때문에 정렬을 할수 없다.
# 과일 = {"사과", "바나나", "오렌지"} # 세트 자료형
# print(과일)

# apple_srt = set("apple") # 애플문자열 폴더에  apple 라는 요소를 담아라 단 set 해서 담아라.(중복을 제외하고)
# print(apple_srt) # >>> {'p', 'a', 'l', 'e'} 중복되는 요소를 제거하고 보여준다. set의 기능

num = {1, 2, 5 ,5, 6}
# print(num) # >>> {1, 2, 5, 6}
# num.add(8) # add 세트안에 1개의 요소를 추가 하기
# print(num) >>> {1, 2, 5, 6, 8}
# num.update([10, 11, 12]) # 세트안에 다수의 요소를 추가한다.
# print(num) >>>> {1, 2, 5, 6, 10, 11, 12}
# num.remove(1) # 세트안에 제외하기 remove >> {2, 5, 6, 8}
# print(num) # >>> {1, 2, 5, 6} #만약 remove로 없는 요소를 지우려고 하면 에러가 발생하지만 discard는 에러를 띄우지않는다.


# empty_set = set() # 빈 세트를 만들기 위해서는 set 명령을 넣고 () 를 넣어야함.  empty_set = {}라고 하면 딕셔너리가 만들어짐.

# 3교시----------------------------
# num.discard(19) #discard 존재하지 않는 요소를 지우려고 해도 오류가 나지 않는다.
# # print(num) >>> {1, 2, 5, 6}  (원본 : num = {1, 2, 5 ,5, 6}) 하지만 중복된 5는 제외시킴
#
# num.clear() # 요소 자체를 전체 제거
# print(num) >>> set()


# # set를 이용한 교집합과 합집합
# a = {1, 2, 3, 4, 5}
# b = {4, 5, 6, 7, 8}
#
# # 합집합
# print(a.union(b))  #union 합집합을 뜻함
# # >>>> {1, 2, 3, 4, 5, 6, 7, 8} set 기능으로 중복된것은 제외하고 합집합을 보여줌
# print(a|b) # >> | 는 합집합 기호이다 (슈프트+ \|W 홉합키를 누른다)
#
# #교집합
# print(a.intersection(b)) # >> {4, 5}  # intersection는 교집합을 뜻한다.
# print(a & b) # >> {4, 5} # & 은 교집합 기호이다.
#
# #차집합 : 교집합을 제외한 남은 요소
# print(a.difference(b)) # >>> {1, 2, 3} # a 변수 리스트를 기준으로 교집합을 제외한 남은 요소
# print(b.difference(a)) # >>> {8, 6, 7} # b 변수 리스트를 기준으로 교집합을 제외한 남은 요소
# print(a-b) # >>> {1, 2, 3} 차집합 기호는 '-'
# print(b-a) # >>> {8, 6, 7}
#
# 컬러 = {"b", "l", "u", "e"}
# print(컬러.pop()) #pop은 가장 끝의 요소를 지우는 명령어인데. set의 특징은 중복을 허용하지 않고 순서가 없기 때문에 마지막이라는 것을 알지 못한다.
# print(컬러) #  >> {'l', 'e', 'b'} 원래라면 pop에 의해 e를 지워질거라고 예상하지만 무작위 단어가 삭제됨


# a = [21, 22, 23, 25, 26]   # 리스트로 되어있는 데이터
# b = [22, 24, 27]
#
# 공통 = set(a) & set (b)  # 리스트로 되어있는 것을 교집합을 구하기위해선 리스트를 set로 변환되어야한다. 그래서 set(a)라고 명명하고 교집한 기호 & 사용
# print(공통) >> {22} 교집합인 22 추출

# 퀴즈
# python_class = ["수현", "현호", "지니", "가인"]
# java_class = ["현호", "지니", "홍수", "찬호"]
# 공통으로 출석한 학생 : >>
# 파이썬만 출석한 학생 : >>
# 자바만 출석한 학생 : >>

# 내가 풀어본것
python_class = ["수현", "현호", "지니", "가인"]
java_class = ["현호", "지니", "홍수", "찬호"]

# 공통출석자 = set(python_class) & set(java_class)
# 파이썬출석자 = set(python_class) - set(java_class)
# 자바출석자 = set(java_class) - set(python_class)
# print({"공통출석자":set(python_class) & set(java_class)}, {"파이썬출석자":set(python_class) - set(java_class)}, {"자바출석자":set(java_class) - set(python_class)})
# >>>> {'공통출석자': {'현호', '지니'}} {'파이썬출석자': {'수현', '가인'}} {'자바출석자': {'홍수', '찬호'}

# 풀이1
# python_class = ["수현", "현호", "지니", "가인"]
# java_class = ["현호", "지니", "홍수", "찬호"]
# 공통출석자 = set(python_class) & set(java_class)
# 파이썬출석자 = set(python_class) - set(java_class)
# 자바출석자 = set(java_class) - set(python_class)

